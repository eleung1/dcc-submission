{spawn, exec} = require "child_process"
nodewatch = require "nodewatch"
httpProxy = require "http-proxy"
express = require "express"
growl = require "growl"

# ANSI Terminal Colors
bold = "\x1b[0;1m"
green = "\x1b[0;32m"
reset = "\x1b[0m"
red = "\x1b[0;31m"

# Constants
SRC = "src/main/webapp"
TARGET = "target/main/webapp"

try
  which = require("which").sync
catch err
  which = null

successful = 
  cs: yes
  test: yes
  lint: yes

task "develop", "Compiles source files, watches for changes and starts server", -> develop()
# Not fully implemented
#task "prod", "Compiles, minifies and joins source files", -> production()
#task "docs", "Generate documentaion", -> docs()
task "tests", "Run tests", -> build -> tests()
task "lint", "Runs cslint over coffee files", -> lint ->

### Use these for testing
task "clean", "Clean target files", -> clean -> 
  colourLog "Target files successfully cleaned.", green
task "build", "Compiles source files to target", -> build -> 
  colourLog "Source files compiled successfully.", green
task "watch", "Watches source files for changes for changes", -> build -> watch -> 
  timeLog "Watching source files...\n"
task "server", "Starts Web Server on port 3001", -> server()
###

launch = (cmd, options=[], callback) ->
  cmd = which(cmd) if which
  app = spawn cmd, options
  app.stdout.pipe(process.stdout)
  app.stderr.on "data", (data) ->
    process.stdout.write "#{red}Failed!#{reset}\n#{data}" 

  app.on "exit", (status) -> callback?() if status is 0
       

develop = (callback) ->
  build -> server -> watch -> callback?() 

prod = (callback) ->
  build -> minify -> server -> callback?() 

build = (callback) ->
  clean -> coffee -> copy -> removeCoffee -> callback?()
  
watch = (callback) ->
  nodewatch.add("src", true).onChange (file,prev,curr,action) ->
    [path..., ext] = file.split(".")
    
    switch ext
      when "coffee"
        timeLog "#{bold}#{file}#{reset} was #{action}d - compiling to javascript..."
        coffee file, -> 
          colourLog "Success!", green
          timeLog "#{bold}#{file}#{reset} was #{action}d - linting..."
          lint file, ->
            timeLog "#{bold}#{file}#{reset} was #{action}d - re-running tests..."
            tests true, -> colourLog "Success!", green
      
      when "handlebars"
      #  timeLog "#{bold}#{file}#{reset} was #{action}d - compiling to javascript..."
      #  handlebars file, -> colourLog "Success!", green
        target = file.replace "#{SRC}", "#{TARGET}"
        timeLog "#{bold}#{file}#{reset} was #{action}d - copying to target..."
        launch "cp", [file, target], -> colourLog "Success!", green

      when "css", "html", "js"
        target = file.replace "#{SRC}", "#{TARGET}"
        timeLog "#{bold}#{file}#{reset} was #{action}d - copying to target..."
        launch "cp", [file, target], -> colourLog "Success!", green
    
  callback?()

clean = (callback) ->
  launch "rm", ["-rf", "#{TARGET}"], callback

copy = (callback) ->
  launch "cp", ["-r", "#{SRC}/", "#{TARGET}/.."], callback
    
removeCoffee = (callback) ->
  exec "find #{TARGET}/js/app -name '*.coffee' -exec rm -rf {} \\;", -> callback?()
   
coffee = (source, callback) ->
  if typeof source is 'function'
    callback = source
    source = "src"
    target = "target"
  else
    target = source.replace("src", "target") + "/../"
  
  options = ["-c", "-o", target, source]
  #launch "coffee", options, callback
  app = spawn "coffee", options
  app.stderr.on "data", (data) ->
    successful['cs'] = no
    err = "#{data}".split "\n"
    growl "#{err[0]}",  
      title: 'CoffeeScript Failed!'
      name: 'coffee-script'
      image: __dirname + '/node_modules/mocha/images/error.png'
    process.stdout.write "#{red}Failed!\n#{err[0]}#{reset}\n"
  
  app.on "exit", (status) -> 
    if status is 0
      if not successful['cs']
        successful['cs'] = yes
        growl "#{options[3]} compiled successfully!",  
          title: 'CoffeeScript Successful!'
          name: 'coffee-script'
          image: __dirname + '/node_modules/mocha/images/ok.png'
      callback?()
      
handlebars = (source, callback) ->
  if typeof source is 'function'
    callback = source
    source = "#{SRC}/js/app/views/templates"
    exec "mkdir -p #{TARGET}/js/app/views/templates"

    fs.readdir(source).forEach (file) ->
      hbs = "#{source}/#{file}"
      js = hbs.replace("#{SRC}", "#{TARGET}").replace("handlebars", "js")
      options = [hbs, "-f", js]
      launch "node_modules/.bin/handlebars", options

  else  
    target = source.replace("#{SRC}", "#{TARGET}").replace("handlebars", "js")
    options = [source, "-f", target]
  
    launch "node_modules/.bin/handlebars", options
  
  callback?()

  
server = (callback) ->
  server = express.createServer();
      
  server.configure ->
    server.use express.methodOverride()
    server.use express.bodyParser()
    server.use express.static "#{TARGET}"
    server.use express.errorHandler
      dumpExceptions: true 
      showStack: true
    server.use server.router

  server.get /^(?!\/?(assets|vendor|js|tests|docs))/, (request, response) ->
    response.sendfile "#{TARGET}/index.html"

  server.listen 3000
  
  # Setup proxy to redirect /ws/* request to the DCC REST server  
  options =
    router:
      "localhost/ws/": "localhost:5380/ws/"
      "localhost": "localhost:3000"

  httpProxy.createServer(options).listen 3001, ->
    timeLog "Development Server listening on http://localhost:3001...\n"

  callback?()

lint = (file, callback) ->
  if typeof file is 'function'
    callback = file
    file = 'src/'
    app = spawn "node_modules/.bin/coffeelint", ["-r", file], { customFds: [0, 1, 2] }
    callback()
  else
    #launch "node_modules/.bin/coffeelint", ["-r", file], callback
    app = spawn "node_modules/.bin/coffeelint", ["-r", file]
    out = []
    app.stdout.on "data", (data) ->
      #if "#{data}".indexOf("Lint") isnt -1
      out.push "#{data}"
        
    app.on "exit", (status) -> 
      if status is 0
        if not successful['lint']
          successful['lint'] = yes
          growl "#{out.join ''}".replace(/([^a-z0-9\/\n\#].*?m)/gi, ''),  
            title: 'CoffeeLint Suceess!'
            name: 'coffeelint'
            image: __dirname + '/node_modules/mocha/images/ok.png'
        console.log "#{green}Success#{reset}"
        callback?()
      else
        successful['lint'] = no
        console.log "#{red}Failed#{reset}#{out.join ''}"
        growl "#{out.join ''}".replace(/([^a-z0-9\/\n\#].*?m)/gi, ''),  
          title: 'CoffeeLint Warning!'
          name: 'coffeelint'
          image: __dirname + '/node_modules/mocha/images/error.png'
        callback?()
      
  
  
  

tests = (watch, callback) ->
  options = ["src/test/coffee/runner.coffee", "--compilers", "coffee:coffee-script", ]
  if typeof watch is 'function'
    callback = watch
    options = options.concat ["--reporter", "spec"]
    app = spawn "node_modules/.bin/mocha", options, { customFds: [0, 1, 2] }
    callback()
  else
    options = options.concat ["--reporter", "progress"]
    #launch "node_modules/.bin/mocha", options, callback
    out = []
    err = []
    app = spawn "node_modules/.bin/mocha", options
    app.stdout.on "data", (data) ->
      out.push data
    
    app.stderr.on "data", (data) ->
      err.push data
    app.on "exit", (status) ->
      if status is 0
        if not successful['test']
          successful['test'] = yes
          growl "#{out.join ''}",  
            title: 'Tests Pass Successfully!'
            name: 'mocha'
            image: __dirname + '/node_modules/mocha/images/ok.png'
        callback?()
      else
        successful['test'] = no
        growl "#{err[0]}".replace(':','!'),  
          title: 'Test Failed!'
          name: 'mocha'
          image: __dirname + '/node_modules/mocha/images/error.png'
        process.stdout.write "#{red}Failed!\n#{err.join ''}#{reset}"
        
# When watching scripts, it"s useful to log changes with the timestamp.
timeLog = (message) -> process.stdout.write "#{bold}#{(new Date).toLocaleTimeString()}#{reset} - #{message}"
colourLog = (message, color=reset) -> console.log "#{color}#{message}#{reset}"